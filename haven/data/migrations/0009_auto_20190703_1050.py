# Generated by Django 2.1 on 2019-07-03 10:50

from django.db import migrations
from simple_history.manager import HistoryManager
from simple_history.models import HistoricalRecords

from haven.data.tiers import Tier


def fix_typo(apps, schema_editor):
    questions = { q['name']: q for q in initial_questions() }
    migrate_question(apps, 'publishable', questions['publishable'])


class Migration(migrations.Migration):

    dependencies = [
        ('data', '0008_historicalclassificationquestion'),
    ]

    operations = [
        migrations.RunPython(fix_typo),
    ]


CLOSED_IDENTIFY_LIVING = 'Does the data identify living individuals?'
CLOSED_PERSONAL = (
    'Will you be working with data related to living '
    'individuals, or derived from such data? (e.g. '
    'pseudonymised or synthetic data)')
FINANCIAL_LOW = (
    'Are the legal or financial consequences of disclosure '
    'low?')
INCLUDE_COMMERCIAL = (
    'Will you be working with commercial-in-confidence '
    'information or third-party intellectual property?')
NO_REIDENTIFY_ABSOLUTE = (
    'Is your confidence that it is not possible to '
    're-identify individuals from the data absolute?')
NO_REIDENTIFY_STRONG = (
    'Is your confidence that it is not possible to '
    're-identify individuals from the data strong?')
OPEN_GENERATE_NEW = (
    'Will you be generating (including by selecting, or '
    'sorting) new personal information about individuals?')
OPEN_IDENTIFY_LIVING = 'Does the data identify living individuals? (e.g. social media data)'
OPEN_PUBLICATION = (
    'Will you be working in an open, continuously published '
    'manner?')
PUBLIC_AND_OPEN = (
    'Are all input datasets to the project publicly and '
    'openly available for use in research?')
PUBLISHABLE = (
    'Could all the data handled or generated be published, '
    'albeit at the loss of research competitiveness')
SOPHISTICATED_ATTACK = (
    'Do likely attackers include sophisticated, '
    'well-resourced and determined threats, such as highly '
    'capable serious organised crime groups and state '
    'actors?')
SUBSTANTIAL_THREAT = (
    'Would disclosure pose a substantial threat to the '
    'personal safety, health or security of the data '
    'subjects?')


def initial_questions():
    questions = [
        {
            'name': 'sophisticated_attack',
            'question': SOPHISTICATED_ATTACK,
            'yes_tier': Tier.FOUR,
            'no_tier': Tier.THREE,
        },
        {
            'name': 'no_reidentify_strong',
            'question': NO_REIDENTIFY_STRONG,
            'yes_tier': Tier.TWO,
            'no_tier': Tier.THREE,
        },
        {
            'name': 'financial_low',
            'question': FINANCIAL_LOW,
            'yes_tier': Tier.TWO,
            'no_question': 'sophisticated_attack',
        },
        {
            'name': 'include_commercial',
            'question': INCLUDE_COMMERCIAL,
            'yes_question': 'financial_low',
            'no_tier': Tier.ONE,
        },
        {
            'name': 'no_reidentify_absolute',
            'question': NO_REIDENTIFY_ABSOLUTE,
            'yes_question': 'include_commercial',
            'no_question': 'no_reidentify_strong',
        },
        {
            'name': 'open_publication',
            'question': OPEN_PUBLICATION,
            'yes_tier': Tier.ZERO,
            'no_tier': Tier.ONE,
        },
        {
            'name': 'substantial_threat',
            'question': SUBSTANTIAL_THREAT,
            'yes_tier': Tier.FOUR,
            'no_tier': Tier.THREE,
        },
        {
            'name': 'closed_identify_living',
            'question': CLOSED_IDENTIFY_LIVING,
            'yes_question': 'substantial_threat',
            'no_question': 'no_reidentify_absolute',
        },
        {
            'name': 'closed_personal',
            'question': CLOSED_PERSONAL,
            'yes_question': 'closed_identify_living',
            'no_question': 'include_commercial',
        },
        {
            'name': 'publishable',
            'question': PUBLISHABLE,
            'yes_question': 'open_publication',
            'no_question': 'closed_personal',
        },
        {
            'name': 'open_generate_new',
            'question': OPEN_GENERATE_NEW,
            'yes_question': 'substantial_threat',
            'no_question': 'open_publication',
        },
        {
            'name': 'open_identify_living',
            'question': OPEN_IDENTIFY_LIVING,
            'yes_question': 'open_generate_new',
            'no_question': 'open_publication',
        },
        {
            'name': 'public_and_open',
            'question': PUBLIC_AND_OPEN,
            'yes_question': 'open_identify_living',
            'no_question': 'publishable',
        },
    ]

    for q in questions:
        q.setdefault('yes_question', None)
        q.setdefault('no_question', None)
        q.setdefault('yes_tier', None)
        q.setdefault('no_tier', None)

    return questions

def insert_initial_questions(model_cls):
    questions = {}
    assert not model_cls.objects.exists()

    for kwargs in initial_questions():
        if kwargs['yes_question']:
            kwargs['yes_question'] = questions[kwargs['yes_question']]
        if kwargs['no_question']:
            kwargs['no_question'] = questions[kwargs['no_question']]
        q = model_cls(**kwargs)
        q.full_clean()
        q.save()
        questions[q.name] = q

    for k, q in questions.items():
        assert k == q.name


def verify_initial_questions(apps):
    ClassificationQuestion = apps.get_model('data', 'ClassificationQuestion')
    stored = ClassificationQuestion.objects.filter()
    initial = { q['name']: q for q in initial_questions() }
    if len(stored) != len(initial):
        raise RuntimeError(f"Expected {len(initial)} questions but there were {len(stored)}")
    for q in stored:
        q = {
            'name': q.name,
            'question': q.question,
            'yes_question': q.yes_question,
            'no_question': q.no_question,
            'yes_tier': q.yes_tier,
            'no_tier': q.no_tier,
        }
        if q['yes_question']:
            q['yes_question'] = q['yes_question'].name
        if q['no_question']:
            q['no_question'] = q['no_question'].name
        q2 = initial[q['name']]

        if q != q2:
            raise RuntimeError(f"Expected {q['name']} to be {q2} but was {q}")


# In a migration, you don't have access to the actual model class, just a historical version
# of it, which doesn't have non-field attributes. This means that
# ClassificationQuestion.history isn't set, and changes to the question aren't captured in the
# history table. This is a set of methods which allows you to write migrations that capture the
# history

def migrate_question(apps, name, kwargs):
    ClassificationQuestion = apps.get_model('data', 'ClassificationQuestion')
    q = ClassificationQuestion.objects.get(name=name)
    if kwargs['yes_question']:
        kwargs['yes_question'] = ClassificationQuestion.objects.get(name=kwargs['yes_question'])
    if kwargs['no_question']:
        kwargs['no_question'] = ClassificationQuestion.objects.get(name=kwargs['no_question'])
    q.question = kwargs['question']
    q.yes_question = kwargs['yes_question']
    q.no_question = kwargs['no_question']
    q.yes_tier = kwargs['yes_tier']
    q.no_tier = kwargs['no_tier']
    q.save()
    history = _attach_history(apps, q)
    history.post_save(q, created=False)


def insert_blank_question_if_necessary(apps, name):
    ClassificationQuestion = apps.get_model('data', 'ClassificationQuestion')
    q, created = ClassificationQuestion.objects.get_or_create(name=name)
    if created:
        history = _attach_history(apps, q)
        history.post_save(q, created=True)


def hide_question_if_present(apps, name):
    ClassificationQuestion = apps.get_model('data', 'ClassificationQuestion')
    try:
        q = ClassificationQuestion.objects.get(name=name)
        q.hidden = True
        q.save()
        history = _attach_history(apps, q)
        history.post_save(q, created=False)
    except ObjectDoesNotExist:
        pass


def _attach_history(apps, q):
    ClassificationQuestion = apps.get_model('data', 'ClassificationQuestion')
    HistoricalClassificationQuestion = apps.get_model('data', 'HistoricalClassificationQuestion')
    manager = HistoryManager(HistoricalClassificationQuestion)
    q.history = manager
    history = HistoricalRecords()
    history.manager_name = 'history'
    history.cls = ClassificationQuestion.__class__
    return history
